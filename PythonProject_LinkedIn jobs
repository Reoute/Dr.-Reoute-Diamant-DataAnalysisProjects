
# ### Import Python libraries

# In[1]: 

import seaborn as sb 
import pandas as pd
import math
import matplotlib.pyplot as plt 


# ### Dataset Explanation
#  #### The data comprises job-related information from LinkedIn job postings scraped over a 2-day period. Key features include company details and job-specific information. 
#  #### The database information can shed light on the salary characteristics offered in LinkedIn jobs in comparison to place of residence, required level of experience, company size, including a combination of several characteristics together. The database also includes references to sponsored versus non-sponsored jobs positions, office-based versus work-from-home jobs, and more...

# #### Read "LinkedInJobs.csv" as DF

# In[2]:


df=pd.read_csv ("LinkedInJobs.csv")


# In[48]:


df


# #### Set index to start with number 1

# In[3]:


index=pd.Index (range(1,33247,1))
df.set_index (index, inplace=True)


# In[50]:


df


# #### Change of column Names

# In[4]:


df.rename(columns={"Co_Nm":"Company_Name","Co_Pg_Lstd":"Company_Page_Listed","Flw_Cnt":"Follower_Count"},inplace=True)


# In[5]:


df.rename(columns={"py_prd":"PayPeriod", "py_lstd":"PayListed", "wrk_typ": "Work_Type", "xp_lvl":"Experience_Level"},inplace=True)


# ### numbers of rows and columns in the DF

# In[53]:


df.shape


# #### General info

# In[54]:


df.info ()


# #### Changing column type where the type is Boolean (not INT) 

# In[6]:


df[['is_remote','is_sponsored', 'base_comp']] = df[['is_remote','is_sponsored', 'base_comp']].astype(bool)


# #### Changing column type where the type is Category (not Object)

# In[7]:


df[['PayPeriod','Work_Type', 'app_typ','Experience_Level']] = df[['PayPeriod','Work_Type', 'app_typ','Experience_Level']].astype('category')


# In[57]:


df.info ()


# ##### Display the first 5 rows

# In[58]:


df.head()


# #### Display the 4 last rows

# In[59]:


df.tail (4)


# #### Display empty cell sum per column

# In[8]:


df.isnull().sum()


# #### Drop column with significant number of empty cells 

# In[9]:


df=df.drop('domain',axis=1)


# In[62]:


df.isnull().sum()


# In[63]:


df.describe()


# ### Conclusions: On the average, the companies in this dataset are midsized. Since the average max salary is 31,866, it's suggests that the average top salary across companies is relatively low. There is also a significant variation, particularly in follower count and salary, indicating that a few companies hold a dominant position in terms of size, salary, and overall popularity. 

# #### Sort by job type - majority of offered jobs are full-time positions

# In[64]:


df ['Work_Type'].value_counts().to_frame()


# #### PayPeriod: Future analyses will take this information into account

# In[65]:


df['PayPeriod'].value_counts().to_frame()


# ### Filter jobs by company name - display jobs from companies that have posted more than 50 positions

# In[66]:


company_counts= df ['Company_Name'].value_counts()
companies_above_50 = company_counts[company_counts > 50]
companies_above_50


# In[67]:


#### Remove the first row showing jobs without a company name
companies_above_50_df = companies_above_50.reset_index().iloc[1: ]
companies_above_50_df


# ### Present salary data according to required experience in descending order (last column- median salary)
# #### I chose to display only jobs with a 'PayPeriod' of 'Yearly' since this category includes more than 8,000 job offers (more than any other valid category) 

# In[68]:


desired_pay = ['YEARLY']
salary = df[df['PayPeriod'].isin(desired_pay)]

salary_by_experience = salary.groupby(['Experience_Level'])[['min_sal', 'max_sal', 'med_sal']].mean().reset_index().round(1)
salary_by_experience_sorted = salary_by_experience.sort_values(by="med_sal", ascending=False)
salary_by_experience_sorted


# ### Present salary data according to region in descending order

# In[11]:


desired_pay = ['YEARLY']
salary = df[df['PayPeriod'].isin(desired_pay)]

salaryByRegion = salary.groupby(['st_code'])[['min_sal', 'max_sal', 'med_sal']].mean().reset_index()
salaryByRegion_sorted = salaryByRegion.sort_values(by='med_sal', ascending=False)
salaryByRegion_sorted


# ### Display maximum salary by region- Plot

# In[13]:


plt.figure(figsize=(15, 10))
salaryByRegion_sorted= salaryByRegion_sorted.sort_values(by='max_sal', ascending=False)
sb.barplot(x='st_code', y='max_sal', data=salaryByRegion_sorted, color='#AC7FC6')
plt.title('Maximum Salary by Region', fontsize=14)
plt.xlabel('Region Code', fontsize=12)
plt.ylabel('Average Maximum Salary', fontsize=12)
plt.show()


# ### Conclusion: the regions with the highest potential salary - CA (California), WA ((Washington), the region with the lowest potential salary- VT (Vermont)
# ### Since XF is an unidentified code, I searched for similarities in the corresponding 'loc' column
# #### The XF region includes various geographic areas, primarily within the United States, such as states, cities, and metropolitan areas. It is characterized by terms like 'Greater,' 'Metropolitan Area,' and specific city-state combinations. Consequently, the conclusions will exclude the XF region code

# In[71]:


df['st_code'] = df['st_code'].astype(str)
filtered_df = df[df['st_code'] == 'XF']
loc_values = filtered_df['loc']
print(loc_values.unique())


# ### For the top 10 regions with the highest average salaries, display salary by level of experience

# In[72]:


df_year_Ex = df[(df['PayPeriod'] == 'YEARLY') & (df['Experience_Level'].isin(['Entry level','Mid-Senior level','Executive', 'Associate', 'Director']))]
top_10_regions = df_year_Ex.groupby('st_code')['med_sal'].mean().nlargest(11).index
df_top_10 =df_year_Ex[df_year_Ex['st_code'].isin(top_10_regions)]
df_top_10 = df_top_10[df_top_10['st_code'] != 'XF']
salary_experience_TopRegion = df_top_10.pivot_table(values='med_sal', index='st_code', columns='Experience_Level', aggfunc='median')
salary_experience_TopRegion


# ### Top 10 Regions by Salary and Experience Level- Plot

# In[73]:


plt.figure(figsize=(16, 10))
sb.heatmap(salary_experience_TopRegion, annot=True, fmt='.0f', cmap='YlOrRd')
plt.title('Top 10 Regions by Salary and Experience Level', fontsize=18)
plt.xlabel('Experience Level', fontsize=16)
plt.ylabel('Region Code', fontsize=16)
plt.tight_layout()
plt.show()


# ### Conclusions: For entry-level positions, the highest median salary is found in the regions of DC (District of Columbia) and NH (New Hampshire).   For executive positions, the highest median salary is found in the regions of CA (California) and DC (District of Columbia).                         For mid-senior positions, the highest median salary is found in the regions of ME (Maine) and SD (South Dakota).                                     For associate positions, the highest median salary is found in the regions of CA (California) and NY (New York).                                        For director positions, the highest median salary is found in the regions of WA (Washington) and VA (Virginia).                                      The most significant difference in salary level between entry level positions and mid-senior positions is in the state of SD (South Dakota). Moreover, this state recorded the highest salary at the mid-senior level.

# ## Salary by experience and company size

# In[14]:


desired_levels = ['Associate', 'Director', 'Entry level', 'Executive', 'Mid-Senior level']
Salary_ex = df[(df['PayPeriod'] == 'YEARLY') & df['Experience_Level'].isin(desired_levels)]
Salary_ex ['company_size'] = pd.cut(Salary_ex['Emp_Cnt'], 
                                    bins=[0, 50, 200, 1000, 5000, float('inf')], 
                                    labels=['tiny', 'small', 'medium', 'large', 'huge'])
salary_ex_size = Salary_ex.groupby(['company_size', 'Experience_Level'])['med_sal'].mean().unstack()
salary_ex_size = salary_ex_size[desired_levels]
salary_ex_size


# ### Salary by Experience Level and company Size- Plot

# In[15]:


plt.figure(figsize=(15, 18))
salary_ex_size = salary_ex_size.plot(kind='bar', width=0.8, color= ['#ffb3ba', '#ffdfba', '#ffffba', '#baffc9', '#bae1ff', '#c6e2ff', '#eeeeee'])
plt.title('Salary by Experience Level and Company Size', fontsize=16)
plt.xlabel('Company Size', fontsize=12)
plt.ylabel('Salary', fontsize=12)
plt.legend(title='Experience Level', bbox_to_anchor=(1, 1), loc='upper left')
plt.show()               


# ### Conclusions:
# ### If you are looking for executive and entry positions, it's better to focus on large companies (especially for executive positions). If you are looking for associate positions, it's better to consider tiny companies. If you are looking for director positions, it's better to consider huge and medium companies. If you are looking for mid-senior positions, it's better to consider medium companies. 

# ### Views By Compagny size

# In[16]:


df['company_size'] = pd.cut(df['Emp_Cnt'], 
                            bins=[0, 50, 200, 1000, 5000, float('inf')], 
                            labels=['tiny', 'small', 'medium', 'large', 'huge'])
ViewsbyCompanysize =df.groupby('company_size')['views'].agg(['mean', 'median', 'count', 'max', 'min', 'sum', 'std'])
ViewsbyCompanysize


# ### Conclusion: Surprisingly, on average, jobs at tiny companies receive the most views. This may be due to the high level of standard deviation in job views across all company sizes

# ### Jobs Views by Region: Analysis of the Top 5 Regions

# In[77]:


df_ex_xf = df[df['st_code'] != 'XF']
top_5_regions = df_ex_xf.groupby('st_code')['views'].sum().nlargest(5).index
ViewsbyRegions = df_ex_xf[df_ex_xf['st_code'].isin(top_5_regions)].groupby('st_code')['views'].agg(['mean', 'median', 'count', 'max', 'min', 'sum', 'std'])
ViewsbyRegions


# ### Conclusion: NY is the region with the highest number of job views, suggesting a robust job market. The high standard deviation indicates varying viewership levels in this country. Given the higher job expectations, the elevated job viewership likely reflects both a substantial supply of available positions and strong demand from job seekers. Among the top five regions, Florida has the lowest number of job views. 

# ### Calculate median and average views for sponsored and unsponsored jobs

# In[78]:


SponsoredViews = df.groupby('is_sponsored')['views'].agg(['mean', 'median', 'count'])
SponsoredViews


# ### Number of job views for sponsored versus unsponsored jobs-Plot

# In[17]:


plt.figure(figsize=(10, 6))
sb.lineplot(x='is_sponsored', y='views', data=df)
plt.title('Views- sponsored versus unsponsored')
plt.xlabel('sponsored/ unsponsored')
plt.ylabel('Views')
plt.xticks([1, 0], ['sponsored', 'unsponsored'])
plt.tight_layout()
plt.show()


# ### Conclusion: Job sponsoring is effective and increases the number of job views

# ### Number of job views for remote versus office-based jobs

# In[18]:


RemoteViews = df.groupby('is_remote')['views'].agg(['mean', 'median', 'count', 'sum'])
RemoteViews


# ### Views Distribution: Remote vs. Office- Plot

# In[19]:


plt.figure(figsize=(8, 6))
views_mean = df.groupby('is_remote')['views'].mean()
colors = ['grey', 'skyblue']
plt.pie(views_mean, labels=['Office', 'Remote'], autopct='%1.1f%%', startangle=90, colors= colors)
plt.title('Distribution of Views: Remote vs. Office') 
plt.show()


# ### Conclusions:
# #### When it comes to remote work, the average number of views per job is significantly higher compared to office-based jobs. This is despite the fact that most positions are office-based, highlighting the increased demand for remote work over office jobs.
